---
alwaysApply: true
---

Project identity
- This is a fun, time-boxed event app for small private festivals/parties.
- Typical scope: runs for 1-3 days, up to ~100 attendees, a few NFC readers.
- Implication: optimize for speed, clarity, and reliability over enterprise abstractions.

Tech snapshot
- Framework: Next.js 14 (App Router) + TypeScript, Tailwind CSS.
- Backend: Supabase (Postgres) + Edge Functions (Deno). Next API routes proxy to Edge Functions.
- Data: simple relational schema; CSVs for seed/demo; config in `config/` and `public/`.
- Key dirs: `app/`, `lib/`, `supabase/functions/`, `supabase/migrations/`, `public/`.

Architecture & structure
- App Router structure lives under `app/`
  - `app/guest/*`: guest dashboard, history, social
  - `app/recipes/page.tsx`: recipe browser and ordering
  - `app/food/*`: food selection
  - `app/admin/*`: admin UI (pure client) calling server routes
  - `app/api/*`: server routes
    - Proxies to Edge Functions (e.g., `getGuestData`, `getDashboardData`, `orderDrink`, `logScan`)
    - Admin server routes: `app/api/admin/{getAll,save,delete}` use service role + `x-admin-password`
    - Food server routes: `getFoodData`, `orderFood` use service role
- Supabase clients
  - `lib/supabase.ts`: anon client for safe public reads only (browser)
  - `lib/supabaseAdmin.ts`: service role client (server-only; API routes/Edge Functions)
- Edge Functions (Deno)
  - `logScan`: handles NFC scans, achievements, and device-configured drink logging
  - `orderDrink`: processes drink orders
  - `getGuestData`: legacy guest data
  - `getDashboardData`: consolidated guest + menu payload
- RLS & policies
  - RLS enabled. Public SELECT allowed for `drink_menu`, `recipes`, `food_menu` via `20250816_enable_public_reads.sql`
  - All writes and sensitive reads go through server routes/Edge Functions with service role
  - Admin UI performs CRUD via `app/api/admin/*` guarded by `ADMIN_PASSWORD`
- Environment vars
  - `NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`
  - `SUPABASE_SERVICE_ROLE_KEY` (server only)
  - `ADMIN_PASSWORD` (server check; UI sends `x-admin-password` from localStorage)
- NFC integration
  - Devices POST to `app/api/logScan` (proxies to `functions/v1/logScan`)
  - `logJager` is removed; `logScan` handles that flow

Design principles
- Keep it simple: straightforward code over patterns (no CQRS/DDD/hexagonal/complex DI).
- Local-first UI: React state/hooks; avoid heavy state libs unless there is a clear pain point.
- Few dependencies: pick the smallest tool that works; avoid unnecessary abstraction layers.
- YAGNI: do not build for hypothetical scale; design for <= 100 concurrent users.
- Ship fast: prefer solutions that can be built and tested in hours.
- Readable over clever: clear code, early returns, small modules.

Error handling and logging
- Show friendly user-facing errors (toasts/messages) where it matters.
- Server logging via console is acceptable; no heavy observability stacks.
- Retries only where they materially improve UX (e.g., flaky network).

Data, consistency, and performance
- Event-tolerant consistency; eventual consistency is acceptable for non-critical stats.
- Caching: prefer simple Next.js or in-memory caching when it clearly helps; avoid complex invalidation.
- Queries: keep simple and indexed; optimize only with evidence of slowness.

Security and privacy
- Secrets in env vars only; never commit secrets.
- Guest names and tag UIDs are private to the event; keep logs minimal and short-lived.
- Admin access can remain simple (env password) unless stricter controls are clearly needed.

Testing and QA
- Right-sized tests: add focused unit tests for tricky logic (time windows, achievements).
- Skip exhaustive E2E unless driven by a bug.
- Manual QA should mirror real flows: NFC scan -> guest dashboard -> ordering -> admin stats.

UX guidelines
- Mobile-first: most usage is on phones at the venue.
- Fast paths: minimize taps to log a drink or view achievements.
- Favor delightful, simple visuals over enterprise polish; Tailwind is preferred.

Feature work guidelines
- Always ask: does this matter for a 1-3 day, <=100 person event? If not, skip or defer.
- Prefer config over code when possible (e.g., `config/event.json`, `public/timetable.json`).
- Reuse existing patterns and utilities in `app/` and `lib/`; keep files small and direct.

Anti-goals (avoid unless justified)
- Microservices, message buses, complex job schedulers.
- Enterprise feature flags, heavy A/B testing frameworks.
- Complex role systems beyond simple admin vs guest.
- Over-abstracted repositories/services with little payoff.

AI assistant guidance
- Default to pragmatic, minimal solutions aligned with this scope.
- Reuse current utilities (Supabase client, API proxies) and file structure.
- Prefer explicit TypeScript types and early returns; avoid over-engineering.
- Keep new files focused and colocated where discoverable.
- If unsure, choose the simpler path and leave a short comment explaining the tradeoff.

Operational notes
- Deploy: Vercel for Next.js; Supabase for DB and Edge Functions.
- Incidents: favor rapid hotfixes over perfect root-cause processes during the event.
- Backups: export CSVs before/after the event for peace of mind.

Summary reminder
- This is a party app. If a choice adds enterprise overhead without clear benefit during a short event, do not do it.
